---
layout: post
title: "express보다 NestJS?"
date: 2023-09-26 14:32:16 +0900
categories: FIBUD BACKEND
---

## NestJS

<img src="https://velog.velcdn.com/images/kisuk623/post/0d6faccb-9cba-480a-ba71-9c9369b6915e/image.png"/>

NESTJS는 node.js를 기반으로 한 웹 프레임워크입니다.
node.js를 기반한 웹 프레임워크라면 유명한 express가 있죠!
FIBUD 백엔드 팀에서는 메인으로 NESTJS를 사용하고 있어요.
인기도는 express가 1위 nest가 2위지만 무섭게 상승 중이지요!

# 그럼 NESTJS가 더 좋은 프레임 워크일까요?

그건 아닙니다! express를 가지고 nestjs와 똑같이 만들 수 있기 때문이죠!
nestjs는 express와 fastify를 래핑하여 api 개발하는데 유용한 기능들은 설정해논 프레임워크입니다.
express는 가볍다는 장점과 엄청난 자유도를 가지고 있습니다. 최소한의 것만 가지고 있는 프레임 워크기 때문에
사람마다 스타일이 너무 다르다는 단점을 가지고 있죠...
반면 NESTJS는 규칙을 만들어 NESTJS사용하는 사람들 끼리 알아보기 쉬워지고 구조에 대한 고민을 줄여주죠!
NestJS에서는 typeScript를 기본으로 제공하고 자바의 spring의 구조를 참고하여 만든 프레임워크이기 때문에
객체지향적인 특성을 가지고 있습니다.

## 객체지향

# 객체지향이요?

객체를 만들고 만들어진 여러 객체들을 조립해 하나의 완성된 프로그램을 만드는 방법론
개발자 맞춤으로 쉽게 말하면
class를 만들고 객체를 만들어 사용한다.

# 그걸 계속 만들어서 쓰나요?

아뇨 NestJs에서 @Injectable 데코레이터를 붙히고 module에 provider에 등록하면 (controller의 경우 @Controller가 있다.)
DI (Dependency Injection)의존성 주입을 해줍니다.! NESTJS가 객체들을 가지고 있고 우리가 필요할때마다 달라고 해 객체간의
의존성을 낮출 수 있습니다. 또 여기서 나타나는 특징인 IOC(Inversion of Control) 제어의 역전은 개발자가 제어할 영역을 프레임워크
에게 위임하는 것입니다. 네스트는 IOC 컨테이너가 있고 이 컨테이너가 객체를 관리하고 생성하며, 의존성을 관리해줍니다.
NEST는 이렇게 객체들간에 강하게 묶여있는 상태를 느슨하게 해줄 수 있는데 이로써 테스트와 재사용성에 효율이 증가하게 되는 것이죠!

이런 걸 왜하냐면 JAVA 수업때 교수님이 지겹게 외치던
객체지향 설계의 5원칙 ! SOLID !

- 단일 책임 원칙 (Single responsibility Priciple)
  - “한 클래스는 하나의 책임만 가져야 한다.”
- 개방 패쇄 원칙 (Open/Close principle)
  - “소프트웨어 요소는 확장에는 열려 있으나 변경에서 닫혀 있어야 한다.”
- 리스코프 치환 원칙 (Liskov substitution principle)
  - “프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.”
- 인터페이스 분리 원칙 (Interface segregation principle)
  - “특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.”
- 의존관계 역전 원칙 (Dependecy inversion principle)
  - "프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.”
    ..
    --객체지향 수업은 아니므로 자세한 설명은 생략--

출처 <a herf = "https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84)">위키백과</a>

이러한 설계 원칙에 따라 객체를 더 쉽게 관리하고 생성하기 위해 사용되는 방식이죠!

## NestJS의 주요특징과 life Cycle

<img src = "https://docs.nestjs.com/assets/lifecycle-events.png">
간단히
호스트 모듈의 종속성 해결 - 초기화 - 실행 - 종료 
이런 사이클을 가지고 있다고 합니다.

우리가 nestjs를 보다 잘 이해하고 개발 위해 필요한건 바로
이 HTTP 요청이 왔을때 NEST가 동작하는 흐름이죠 !

<img src = "https://www.rldnd.net/_next/image?url=https%3A%2F%2Fwww.notion.so%2Fimage%2Fhttps%253A%252F%252Fs3-us-west-2.amazonaws.com%252Fsecure.notion-static.com%252F5ab40eb5-d954-4b6a-b2ff-395f0a602301%252Fimages_haron_post_e2587453-9aa2-4f2d-9ae4-0c8c024ed42f_image.png%3Ftable%3Dblock%26id%3D932e63d8-011c-4398-851e-823db875cbe7%26cache%3Dv2&w=2048&q=75">

1. Request 요청을 받고
   - 클라이언트로 부터 요청을 받는다.
2. 미들웨어가 동작한다.
   - express와 fatify 위에서 동작하기 때문에 express의 미들웨어나 커스텀 미들웨어를 만들어 사용가능
3. guards
   - 가드는 사용자의 인증을 검증할때 사용된다. 로그인 안한 회원을 막는 클럽에 가드..? 문지기..?
4. pre-interceptor
   - 요청이 컨트롤러로 전달되기 전에 실행 되는 인터셉터로 요청을 가로체고 요청을 변경하거나 검증할 수 있는 기회를 제공한다.
5. pipes
   - 요청이 들어온값을 원하는 값으로 바꿔주거나. 원하는 값으로 들어왔는지 유효성 검사를 해준다.
6. controller
   - 라우터의 기능을 한다.
7. service
   - 비지니스 로직 등 실제 요청을 처리하는 로직들을 처리하는 곳
8. post-interceptor
   - 응답이 클라이언트로 전송되기 전에 실행되는 인터셉터로 응답을 수정하거나 로깅 및 추가정보를 추가하는데 사용된다.
9. exception filter
   - 예외처리를 담당한다. 예외 상황이 발생하면 상황마다 원하는 형태로 가공해서 응답할 수 있게 만들어준다.
10. Response
    - 클라이언트로 응답을 보낸다.

이 기능들은 nestjs의 특징이기도 합니다!

이 외에도 NESTJS는 공식문서가 정말 잘 되어있기 때문에
공부할때 공식문서를 참고하면 많은 힌트를 얻을 수 있습니다!

마스코트가 고양이인데 귀엽답니다 ?

<a herf = "https://nestjs.com/">공식사이트</a>

여기까지 NestJS 에 대해 알아보도록 합시다..

###### EDIT BY JAEMIN
